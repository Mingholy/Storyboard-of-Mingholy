---
title:  "Linux内核 11-18"
date:   2015-11-18 20:30:00
cover: "2.jpg"
tags:
    - Linux
    - OS
category: "Linux"
---

##  最后一节课

**清空页表页目录表的目的**
* 与父进程脱离关系
* 准备形成缺页中断，引导进程加载（P位为0，引发缺页中断。）

除了寄存器页表页目录表其他都是线性地址。
`trap_init`引导缺页中断。
汇编`_page_fault`中`_do_no_page`调用缺页处理函数。
`_do_wp_page`调用写保护处理函数。

> 内核操作-共享资源-写保护只读处理。这里的只读操作只针对该页。在页表项中`rw`项置0。共享进程对父进程只读，子进程同样只读。如果需要写操作，不论哪个进程先发起写请求，首先`get_free_page`复制该页到新页，当写保护结束将这个页分配给另外一个进程。写实复制都以页为单位。
> 注意，页共享是父子进程都有页，缺页中断是没有页了。共享导致页写保护。加载进程导致缺页中断。

`do_no_page`
1. 首先确认缺页中断是加载进程引起的。
2. 接着确认是否可以通过共享获得页。
3. `for`循环连读4个块。`block+1`让出文件头。
4. `bread_page`是读一个页到缓冲区，占用4个块。读盘动作总要先申请缓冲区。
5. 一次从文件上读取一个页大小。
6. 缓冲区操作建立：`bh``request`

> 加载进程-缺页`page_fault`引发硬件中断-进入内核态处理页`do_no_page`-中断返回加载进程的用户态。
> 如果页不够用，就继续缺页中断。
> 缺页-加载-运行 循环。

问题：`_do_wp_page`中断怎么引发的？
> 在`share_page`的`try_to_share`中，`if(phys_addr & 0x41) != 0x01`。即置`P`和`Δ`为1。

## 进程退出
最先启动退出的是进程自身。

`_exit`
链接器在应用程序上加上`_exit`。直接贴机器码。
通过`int80`到`sys_call`走系统中断那一套。
`do_exit`
执行各种内存释放操作。进程不能由进程本身创建。同样退出也不能由自己退出。需要由父进程来操作。此处只是发出请求，完成自身能够执行的任务：释放内存，清空进程槽，清空文件访问关系。等等。最后将进程的状态改为`TASK_ZOBIE`，`僵死状态`。
**注意现在还在int80状态下，而此时一般的`iret`已经无进程可以返回，所以只能`tell_father`**。
这就涉及进程间通讯。(参见第八章)
> 考虑到进程之间有非常明确的边界，如何实现这种需求？
> * 管道。
> 思路：进程都可以读写盘。但是盘读写速度太慢。改用内存。使用文件的形式，存在内存里。发信进程存盘，收信进程读盘。在内存的虚拟盘中，由通讯双方独享的一个小缓冲区。
> * 信号。
> 思路：退出进程遗留部分需要父进程处理。一个父进程可以有多个子进程。如何得到进程退出的信息？轮询？中断？
> 实际：仿中断。软中断。所有的进程都有`int80`，就利用这个。

`tell_father`向父进程发送子进程退出信号。只要父进程使用`int80`就将接收到信号。
发送信号之后调用`schedule`。
一旦调度到父进程，`schedule`肯定不是第一次运行，一定从中间(`ljmp`下一行)运行回到`ret_from_sys_call`，这其中就有一个信号处理函数`_do_signal`。随后清栈，`iret`后回到`int80`下一行。如果没有`_do_signal`父进程将回到用户态继续运行。而现在由于它的存在，进程就指向了`wait`。由它引发`sys_waitpid`(**书上419页，`_do_signal`**)。此间内核态到用户态如何转换？软中断`int80`时，保存现场压栈，栈是内核栈，内容是用户态时调用`int80`的下一行。也就是说内核栈弹出的内容将是用户态。现在就将内核栈上保存的内容，复制到用户栈上。然后修改内核栈，使进程转向父进程的`wait`，再`int80`执行`sys_waitpid`开始清理。清理结束之后就要根据用户栈内容到回到父进程的用户态。至此子进程退出彻底完成。
