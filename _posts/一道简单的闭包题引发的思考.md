---
title: '一道简单的闭包题引发的思考'
date: 2017-08-15
cover: "7.jpg"
category: "JavaScript"
tags:
    - 闭包
---
直接上代码：
```js
function Foo() {
    var i = 0;
    return function() {
        console.log(i++);
    }
}

var f1 = Foo(),
    f2 = Foo();

f1(); // 0
f2(); // 1
f2(); // 0
```
我第一次做错了这个题，主要是考虑了一个点：`引用`。

两次赋值，的确是得到了两个不同（地址）的函数对象，但我错误地以为，两个不同的闭包中，里面的i还是指向相同的`Foo`中的`i`。

实际上，这里的`i`是值，值都是在函数域建立之后就初始化好的。通过两次赋值得到的不同闭包，里面的i都已经按照`Foo`中的值初始化好了，即为0。因此在不同的闭包中打印`i`，第一次永远都是0。
