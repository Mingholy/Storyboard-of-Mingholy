---
title: "JavaScript基础"
date: 2017-03-20 17:10:00
cover: "3.jpg"
category: "JavaScript"
tags:
    - JavaScript
---
> 这个系列旨在夯实自己JS基础。很多听过见过存疑的记不住的记住且重要的点都要找到答案，因为JS的点还是很多的，并不是写过就能够学好，反过来很多东西书上也没有，结合经验会记得更牢。每一章把这些点总结出来，备忘当做提升。关键知识点：
  * 操作符
  * 函数对象的`arguments`属性

<!--more-->

# 第二章：在HTML中使用JavaScript
## XHTML平稳退化hack
XHTML中使用内嵌脚本的hack，可以保证平稳退化，在各种浏览器中都可用
{% codeblock lang:html %}
<script type="text/javascript">
//<![CDATA[
  function(){
  ...
  }
//]]
</script>
{% endcodeblock %}
## 文档模式  
主要影响CSS内容呈现和JavaScript执行。
* **混杂模式：**未声明文档类型即进入混杂模式，不同浏览器差异巨大。
* **标准模式：**行为接近标准规范
混杂模式实际上是浏览器厂商为了使新的浏览器同样兼容老旧站点而创立的，在激活混杂模式后，浏览器会模拟老旧浏览器的行为来呈现站点。

## 一些标签和属性
* `<noscript>`在浏览器不支持脚本或脚本被禁用时显示（一般用来提示）的标签
* `defer`属性：延迟解析，在文档加载完全后，按照顺序解析；但事实上并不一定按顺序
* `async`属性：异步解析，只适用于外部脚本，所有带有该属性的`<script>`标签立即下载资源，但不一定按顺序执行，使用时需要确保不同脚本相互无依赖

# 第三章：基本概念
## 语法
### 命名
与CSS类名不同，ES应该遵守驼峰命名方法。可以包含：字母、下划线、美元符号、非开头数字
### 数据类型
`typeof`操作符会返回的一些信息：
* `undefined`：所有未初始化的值
* `boolean`
* `string`
* `number`
* `object`
* `function`

这些是判断一个对象所属类型时需要用到的信息，但是它们并不是**“类型”**。
数据**类型**包括：
* `Undifined`
* `Null`
* `Boolean`
* `Number`
* `String`
* `Object`
前五种是基本数据类型，后一种是复杂数据类型。

#### 基本数据类型
其中，`Undefined`和`Null`是单值类型。`Undefined`类只有一个值`undefined`，而`Null`类的值`null`则是一个空**对象**指针：
{% codeblock lang:javascript %}
typeof null; //"object"
toString.call(null); //"[object Null]"
var o = new Object;
toString.call(o); //"[object Object]"
null == undefined; //true 不同类但"=="会尝试转换类型以比较值
null === undefined; //false 不同类"==="就是要判断是否是同类型的
{% endcodeblock %}
可以发现不同的类型检测手段会返回不同的结果，一个返回值信息，一个返回类的名字。
>注意：
  * 虽然`typeof`对未声明和未初始化的变量都会返回`undefined`，但是它们有本质上的不同。比如未声明的变量作为函数参数时会报`RefereneError: z is not defined`错误，而未初始化的变量作为函数参数却可能会得到返回值，虽然这在绝大多数情况下不是我们想要的那个。
  * `null`应该被视为是一个即将赋值成对象的变量的初始值，方便检测该变量是否已经保存了一个对象的**引用**。
  * `Boolean`类型区分大小写，`true`不是True，`false`也一样。不同类型会按照`false`对待的值有：空字符串、0和`NaN`、`null`、`undefined`。
  * 注意`NaN`也属于`Number`，虽然它的意思是“不是数字”。检测它需要用`isNaN()`，具体参见[IFE2017任务105-可视化排序算法#3](http://ming-holy.space/2017/03/13/IFE2017-105/#简单的合法性判断——类型检测小trick)。
  * `Number`类的值，以0开头的会parse成八进制，0x则对应16进制，有正负无穷的define值，与C类似。
  * 不要测试特定浮点数的**值**，因为JavaScript计算浮点数存在误差。
  * 关于字符串`String`类型，有一个类似Python中不可变量的概念存在，一旦创建即不可更改，更改即删除后重建。
  * `String()`与`toString()`方法，前者接受疑似字符串作为参数，会尽力将它转化为字符串，包括`null`、`undefined`和`NaN`；后者则接受基数作为参数，用于将数值按照该基数解析为字符串。

关于`parseInt()`的一个小...有趣的点，来自UESTC前端群：
{% codeblock lang:javascript %}
[1, 2, 3].map(parseInt); //[1, NaN, NaN]
{% endcodeblock %}
这是因为`Array`的`map`函数实际上将数组中的元素和它的索引作为参数都传给了`parseInt()`，而`parseInt()`第二个参数是`radix`，也就是基数，在解析时会遇到“将2转换成1进制的数，将3转换成2进制的数...”这样的问题，当然就会转换失败，返回`NaN`。  
延伸开来，我们也就知道虽然在ES5中直接把"070"塞给`parseInt()`，并不会得到一个八进制数，但我们可以指定基数得到想要的结果。

#### 复杂数据类型
`Object`方法：
* `constuctor`：构造函数`Object()`
* `hasOwnProperty()`：检查实例中是否存在某属性，用来辨别一个属性是原型所有还是实例私有
* `isPropertyOf()`：检查原型
* `propertyIsEnumerable()`：检查属性本身的元属性——枚举性
* `toLocaleString()`：返回对象的与执行环境地区对应的字符串表示
* `toString()`：返回对象的字符串表示
* `valueOf()`：返回值
这是JavaScript中所有对象的基础，所有对象最终都以`Object`为原型，例外的是与浏览器相关的宿主对象，如BOM和DOM对象。

### 操作符
#### 一元操作符
需要注意的是操作符进行的隐式类型转换：
* 作用于`Boolean`类型时，变量转化成的0或1并作为`Number`类型
* 对于无法解析成数字的字符串，它将被转化为`NaN`
* 应用于对象则先调用`valueOf()`函数得到一个值，再操作；如果得到`NaN`则再调用`toString()`。对象最后会变为数值变量。

#### 位操作符和逻辑操作符
数值存储机制上与C类似。
位操作符：
* `~`：按位非
* `&`：按位与
* `|`：按位或
* `^`：按位异或
* `<<`：左移
* `>>`：有符号右移（保留符号右移），即右移不影响符号位
* `>>>`：无符号右移（不保留符号右移），即右移也影响符号位
逻辑操作符：
需要注意的逻辑与（`&&`)和逻辑或(`||`)操作都是是短路操作，如果前件能决定该表达式的值，则不会去判定后件；否则会要对后件求值，并要求值不得为`undefined`。当前件可以决定表达式的值时，不会对后件求值，这时就不会有类型要求。

#### 乘性操作符
关于乘除需要注意的是：
* 其中一个操作数是`NaN`，结果就是`NaN`
* `Infinity`与0做乘运算，结果是`NaN`
* `Infinity`被`Infinity`除，结果是`NaN`
* 0/0得`NaN`
关于求模需要注意的是以下情况将返回`NaN`：
* 无穷大模有限大
* 0模有限大
* 无穷大模无穷大

#### 加性操作符
需要注意的是0有正负号，同号跟随符号，不同符号0相加得+0。
以下结果是`NaN`：
* 无穷大量之间相加减，按照初中思维应该得0的情况，都是`NaN`
* 操作数中出现了`NaN`

#### 相等操作符
相等指的是`==`，这种比较操作符会强制转换类型，所以判断不了操作数是否是同类型并且值相同的。
全等值的是`===`，不强制转换类型。

### 语句
需要注意的是`for-in `语句。在实际使用中，它迭代的是一个对象的所有**属性**（而非内容，更不是其中可迭代的对象，比如数组元素）。但是迭代顺序是不确定的，因浏览器而异。

`label`语句没见过，它是一个标记，可以跟在`break`或`continue`后使用，作为跳出的目的地接着执行代码。感觉这个东西有点像`goto`，破坏程序结构的存在。但书中并没有说很不推荐用，只是说要用一定要添加描述性的标签， 且不要嵌套过深。

不过另外一个语句`with`倒是不推荐使用，它是用来设置作用域的，将它内部的声明都局限在一个特定对象内。**严格模式下不能使用。**并且对性能有影响。

其他的内容都能在C、python等语言中找到影子。

### 函数
查看一下函数的属性都有什么：
{% asset_img function-properties.png 函数的属性%}
这里面有一个`arguments`对象，它与数组类似但并非数组实例，能够通过索引取到里面元素的值。它是隐式的参数列表。也就是说，在声明函数时，可以不指定参数的名字，而使用`arguments`对象来获取参数；在使用参数时，也可以传递多于或少于所声明数量的参数。
>命名的参数只提供便利，但不是必须的。...其他语言可能需要事先创建一个函数签名，而将来的调用必须与该签名一致。但在ES中，解析器不会验证命名参数。

关于`arguments`需要注意的是：
* 形参的值永远与`arguments`内相应位置的值保持一致。比如：
  {% codeblock lang:javascript %}
  function doAdd(num1, num2) {
    arguments[1] = 10;
    alert(arguments[0] + num2);
  }
  {% endcodeblock %}
  这里的`num2`在函数内部就与`arguments[1]`保持一致，函数内部设置了`arguments[1]`为10，则`num2`也为10。
* 但是它们并非是同一内存空间的引用/指针；它们是独立的两个 变量，只是值同步。
* 如果调用`doAdd(10)`，则会弹出`NaN`。因为`arguments`的长度取决于**传入对象的多少**，而非形参列表的长度。只传入一个参数的时候，`num2`未指定，由于传入长度只有1，`arguments`也不会同步它的第二个元素，因此最终`arguments[1] === undefined`，得到的结果就是`NaN`。
* **ES中所有参数传递都是传值，不可能通过引用传递。**

### 没有重载
其他语言的函数可以通过区别接受参数的类型和数量（即函数签名），对一个函数进行重载，但ES中没有。后定义的函数会覆盖先定义的函数，但是可以通过在函数中判断传入参数的类型和数量，来进行不同的处理，作为没有重载的弥补手段。
