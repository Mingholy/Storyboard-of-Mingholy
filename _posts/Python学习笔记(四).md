---
title: Python学习笔记(四)-关于闭包、高阶函数
date: 2017-03-04 21:44
cover: '6.jpg'
category: "Python"
tags:
    - Python
---
今天看了一些关于返回函数，闭包和正则表达式替换的一个小trick。

### 返回函数
这一块的内容...我已经不知道该怎么说好了。因为这一块和闭包联系非常紧密，而闭包又是JavaScript的必会内容。其实已经看了好几遍相关内容了，就是没理解也记不住。  
昨天在尝试解决同学的一个svg不能插入html元素的问题时，尝试使用闭包，也失败了。虽然最后问题所在并不是闭包能解决的，但是还是感觉到，看知识是一回事，自己运用它来实现功能、解决问题是另一回事。

<!-- more -->

在JavaScript中，函数也是个对象，把函数作为一返回值再正常不过。Python其实也是一样。如果不需要一个函数立即运行，可以把它放在另一个函数里，并且作为外层函数的返回值。这样当运行外层函数时，**将按照内层函数的样子“实例化”一个对象**，把这个对象返回。（不知道这么理解对不对。）这样内层函数将不会立即执行。

同时，内层函数将可以引用外层函数的所有参数和局部变量。这也是一种能够将函数内部的变量暴露供外界使用的方式。（[阮一峰关于闭包的解释](http://www.ruanyifeng.com/blog/2009/08/learning_javascript_closures.html)）

需要注意的是：既然我上面说是按照内层函数的样子实例化一个函数对象，那么就意味着如果多次调用外层函数实例化了多个内层函数返回值，则每一个返回值都是不同的对象，尽管它们的内容一模一样——都是按照同一个函数生成的。

这种结构就叫做**闭包**。

### 闭包
使用闭包有一个陷阱。比如教程上的例子：

{% codeblock lang:python %}
def count():
    fs = []
    for i in range(1, 4):
        def f():
             return i*i
        fs.append(f)
    return fs

f1, f2, f3 = count()
{% endcodeblock %}

可以知道，`count()`被调用了三次，“实例化”了三个对象分别赋给了`f1`、`f2`、`f3`。当然，里面的`i`就从1变为了3。

但是，我们知道的是返回的三个函数对象，并没有被执行。那么当分别执行他们的时候，会有不同的结果吗？答案是否定的。由于已经`i`从1变为了3，最后运行每个返回的函数对象都将得到9，也就是`i=3`的情况。这是因为（我猜的）每个返回的对象它持有的外层函数的变量并非是由他们自己独有的，而是拥有了一份外层函数变量的引用/指针，在实际运行时，还会去外层函数里查询变量的值，再进行计算。

那么怎么引用循环变量的不同值呢？首先考虑为什么它们都会引用相同的值。因为它们在创建后都没有立即执行，这就给了循环变量以改变的机会。因此只要建立一种机制，使得循环变量改变后立即执行相关函数将该变量保存下来即可。于是有：

{% codeblock lang:python %}
def count():
    def f(j):
        def g():
            return j*j
        return g
    fs = []
    for i in range(1, 4):
        fs.append(f(i)) # f(i)立刻被执行，因此i的当前值被传入f()
    return fs
{% endcodeblock %}

其中我们建立了一个中层函数，它的作用是，一旦被执行，就使用得到的参数`j`，创建一个`g()`函数对象。实际上，在循环中它所建立的`g()`函数对象里面的返回值就已经被确定为了，分别是`1*1`、`2*2`、`3*3`。这样，将不断改变的循环变量绑定到函数参数上，就可以实现引用循环变量的功能。

### 匿名函数
匿名函数实际上就是没有名字也不会重复的函数。可以接受参数，也可以作为返回值。作为返回值的情况比较常见。写法是：

{% codeblock lang:python %}
def build(x, y):
    return lambda: x * x + y * y
{% endcodeblock %}

### 正则替换字符串的一个小trick
**问题：**定义了一个正则表达式用来在字符串中匹配具有特定模式的子串。字符串中含有多处匹配，但它们匹配到的字符串可能相同也可能不同，比如正则表达式要匹配字符串中的“一两”、“二两”等。现在要在字符串中为每处匹配后面添加一个空格。怎么办？
**陷阱：**`re.match(regexp, string)`要求正则能从开头就匹配到结果。`re.search(regexp, string)`只会返回匹配到的第一个对象。因此是不能够通过取到`match`对象的`group`来获取每一个匹配结果的。并且，如果以迭代方式替换每一个匹配结果，如果匹配结果中有重复的，就会出现重复替换，即当“一两”被替换成“一两\_”后，如果后面又匹配到一个“一两”，前面的一两就会被替换成“一两\_\_”。
**解决方案：**给`re.sub()`函数传一个匹配函数。我猜`re.sub()`是一个高阶函数，它可以接受一个函数作为参数，根据函数的内容来决定替换结果。

{% codeblock lang:python %}
def example(line):
    reg_exp = r'[一二两三四五六七八九十][钱分两](（.+?）)?'

    def repl(match):
        return match.group(0) + ' '

    line = re.sub(reg_exp, repl, line)
    return line
{% endcodeblock %}

我猜是这个样子的：`re.sub`方法在进行正则匹配的时候会生成自己的`match`对象，如果`repl`需要就传给它做处理。正好`repl`返回了一个字符串，满足了`re.sub`对参数的要求，于是成功替换，对每一个`match`的结尾都加了个空格。
