---
title:  "Linux内核 11-04"
date:   2015-11-04 18:00:00
cover: "2.jpg"
tags:
    - Linux
    - OS
category: "Linux"
---

## 缓冲区 buffer

*  本质：一块内存
*  目的：快
*  限制：内存是有限的，不能无限制地划分缓冲区。

为了获得最高的效率，已经进入缓冲区的数据在缓冲区保留的时间应该尽可能滴长。

### buffer_head

通过buffer_head的数据结构定义知道，它采用了链式结构。

*  指针b_data指向数据块。
*  设备号b_blocknr和块号b_dev经常连用。一个块只有一个管理信息，存入的数据归属具有唯一性。
*  整个硬盘空间，每个块都是独立并且唯一存在的，通过设备号和块号两个参数唯一确定。
*  计数器b_count计数此时正在操作缓冲块的进程的个数。
*  b_dirt脏位，表示块已经被写过。
*  b_lock表示当前块正在被操作，读或者写。
*  b_uptodate表示更新位。

>*  调度切换以机器指令为单位，不对操作进行原子化限制，可能出现数据错误。于是产生加锁的解决方法。然而加锁的方式会引发很多问题，一种是在加锁的瞬间进程被切换，另一种的一个典型就是死锁。
*  两个以上的进程同时访问同一个共享数据区，只要至少一方发生写操作，它就叫临界区。出现三类问题：生产者消费者问题，理发师问题，哲学家就餐问题。

这里的解决方式是加锁的同时关闭中断，此时中断还会发生但是不会引起进程切换。但是这样做也会关闭时钟中断，会使得进程切换点不够整齐。当前的切换方式只以时间为标准，不关心代码内容。所以才会发生一个操作没有做完就切换进程。另外一个影响是，关闭中断还会关闭外设中断。否则，当进程等待外设io操作的时候切换进程，中断操作会立即执行，而如果新进程所要操作的数据恰好是之前进程的数据，就引发了错误。(这里没太听清，也不太懂)

隐含的问题：

>这样的机制建立了资源操作的独占性，使得程序的并行执行模式由于资源有限强行变为串行模式，而资源永远是有限的，这有悖于操作系统的设计思路，使得程序执行效率降低。而要想获得高效率必须尽可能使程序并发执行。这是一个旷日持久的矛盾。

由进程到缓冲区/缓冲块之间的关系，由buffer_head管理，由缓冲区到外设io的关系，由request项管理，有单独的一段程序实现。

进程首先查询数据是否在缓冲区中存在。如果有就直接读。如果没有，看是否有空缓冲区，如果有建立缓冲块并与请求项建立关系。

分开管理有利于获得高效率。

前面已经提到，数据应该在缓冲区中存留得尽可能久。那么buffer_head中哪些东西和存留时间有关？
**设备号和块号**
一个缓冲块建立起来，就确定了设备号和块号。一定有一个进程，要么读要么写，建立了这个缓冲块。当这个进程结束操作之后，乃至它退出不再存在，b_count为0，缓冲块仍然存在而不撤销吗？
**不撤销。缓冲块只建立不撤销。以防还有后续进程前来读取。**
>即使后续进程与建立缓冲块的进程没有任何关系，它仍然能够读取以前建立的缓冲块。
所以不论进程如何变化，在数据存在的期间保持不变的只有设备号和块号。

**那么缓冲区岂不是要被塞满？**

这取决于引用计数b_count。由于缓冲区没有撤销废除机制，所以只能说b_count=0的缓冲块，可以被替换，但并不是必须且立即的。

>当一个进程需要新建缓冲块，且此时没有空缓冲区，这就需要查看哪些b_count=0，按照先后顺序将它分配给新的进程，更换设备号块号，变成一个新的缓冲块。
>建立块的hash_table对快速找到所需要的块非常有帮助。

在之后对缓冲区的操作都是使用设备号和块号作为参数。
