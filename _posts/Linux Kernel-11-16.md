---
title:  "Linux内核 11-16"
date:   2015-11-16 20:30:00
cover: "2.jpg"
tags:
    - Linux
    - OS
category: "Linux"
---

## 进程的加载与退出

`云里雾里`

`do_execve`

`文件头`：通过文件头确定文件类型。首先将文件头读取缓冲区，在缓冲区确认这个信息。

现在我们要加载一个可执行文件。加载它就需要创建进程。父进程创建子进程之后，要么共享父进程的资源，包括代码，要么加载自身的代码。

linux要求代码需要是只读的。防止被随意篡改。

代码很短的时候，到不了一个页，应该怎么装？

正是因为代码需要只读，而数据则是频繁变化的，因此它们一定要分头加载，装入两个不同的页中。
而这一“分头的”的操作并没有体现在代码上，原因在于`ZMAGIC`，魔数。

>内核在必要时从二进制文件中加载独立的页面，执行头部，代码段和数据段都被链接程序处理成多个页面大小的块。内核加载的代码页是只读的，数据段的页面是可写的。

随后进行检验，拷贝环境变量。

一个文件具有inode，它的路径有另一个文件的内容指向，而它本身的inode又有另一个文件指向。最终最后一个就是根inode.

>内存中的inode内容要比硬盘中的inode内容多一点。

根据之前读到的文件头与进程关联。注意，此时并没有加载。

加载之前首先要与父进程脱离关系。
首先就是清理。

由当前进程脱钩。

`free_page_tables`
清空页表项和页目录表，为何以ldt为标准？
因为结构都是线性的，按照线性吵结构清空即可。
要想脱离父进程，就把它的那份与父进程共享的代码和数据清空。
>注意：这里仅仅是把它的这份放掉，父进程自己还有一份，不受影响。

接下来又要修改ldt。为什么要改它？
父子进程共享，线性并没有共享。
`copy_process`之后的的`copy_mem`其中的
```
    new_data_base = new_code_base - nr* 0x4000000
```
其中`nr`来自于`copy_process`，`find_empty_process`遍历`task`数组之后返回`nr`，父子进程`nr`不同，线性地址空间也不同。
>父子进程共享的时候，把限长也共享了。虽然每页有64MB，但并不需要把它全占满。原则：够用即可。卡到8MB，多了也不给。

新的操作系统，一个进程占满4G线性地址空间，并且内核与用户共用。
特权级问题：代码能随便跳特权级吗？
>只考虑段，可以。特权级落实到内存上但是在CPU上动手。实际上是CPU寻址权限控制/访问权限控制。执行谁的代码就是谁的特权级。
>实际上还是可以阻止这种做法。`分界。`内存分页的时候，卡到某一位置剩下的就不分配了，即使有线性地址也不能访问。无论是内核和用户，都要经过内存分页。
将用户段与内核段线性排列而非重合，可以吗？不可以。因为系统代码使得内核线性地址空间就16MB，也就是当时linus的机器的物理内存。内核的线性地址宽度至少要覆盖物理内存。必须要覆盖全部内存，为了获得最大寻址。用来管理内存分页。否则没有分页的内存不能用。

>段间跳转仅限于同特权级。内核不是通过线性地址来管理内存的，并不需要通过段间跳转来管理。但它仍然可以通过内存分页管理，直接动页物理地址。这时段的作用被淡化，内核线性地址顶两头。

`change_idt`
父进程的线性地址，与子进程的线性地址并不共享。创建进程时`nr* 0x4000000`已经给了不同的基址，不变的就是限长。
证据：

*  `copy_mem`只设置了段基址，根本没有动限长。
*  在它之前的`copy_process`也只是拷贝了ldt tss，其中限长直接继承了，而且没有改动过。
*  `copy_page_tables`接受的`data_page_limit`也是由`get_limit`获得的父进程的限长，没有更改过。
