---
title: "JavaScript数据类型与变量作用域"
date: 2017-03-20 22:16:00
cover: "4.jpg"
category: "JavaScript"
tags:
    - JavaScript
---
>关键知识点：
  * 数据类型
  * 作用域
  * 变量提升
  * 垃圾回收机制

# 第四章：变量、作用域和内存问题
好，我们一进入第四章接触到的第一个问题就是传说中的深浅复制的问题。  
<!--more-->
其实它的第一个节标题是：
## 基本类型和引用类型的值
但是下一页马上出现复制变量值，忽然就想到了JavaScript的一个经典问题：深浅复制。（以及jQuery的`extend()`，待会总结一下，暂且标题党一下。）
首先还是看基本类型和引用类型。基本类型就是上一个笔记中出现的六大数据类型中的前五个，其中两个单值类型`Undefined`和`Null`，还有`Boolean`，`Number`和`String`。

### 关于复制
基本数据类型，如`Number`的复制是值复制，而复杂数据类型如`Object`类的复制是引用复制。也就是说将一个`Object`类型的变量赋值给另一个变量，赋值的其实是同一个对象的指针（引用），它们指向堆内存中同一个对象。

但是如果将对象作为参数传递给函数，这时一定是按值传递的，不可能出现按引用传递。书上的例子中：
{% codeblock lang:javascript %}
function setName(obj) {
    obj.name = "Nicholas";
    obj = new Object();
    obj.name = "Greg";
}

var person = new Object();
setName(person);
alert(person.name);  //"Nicholas"
{% endcodeblock %}
如果是按引用传递，即参数`obj`是`person`的引用，那么运行`setName`时，`obj.name`第一次被赋值成"Nicholas"，紧接`obj`就被赋值成为新对象了，也就是说它所引用的`person`对象就被赋值为新对象了，那么函数结束后得到的`person.name`属性应该是最后设置的"Greg"。然而结果并不是，因为当`person`作为对象参数传给该函数时，它的值复制给了`obj`，而`obj`就作为函数`setName`的局部变量被修改了，它的属性值最终是什么，其实已经与`person`无关了。
实际上引用类型的传递也是按值传递，只是传递的值是指向该引用类型对象的指针。如下代码可以说明：
{% codeblock lang:javascript %}
function setName(obj) {
    obj.name = "Greg";
}
var person = new Object();
person.name = "Nicholas";
setName(person);
alert(person.name); //"Greg"
{% endcodeblock %}
这是因为局部变量`obj`和外部变量`person`都指向内存堆区的同一块空间，这块空间存储的内容相同。通过`.`操作符可以修改这块空间里存储的属性`name`的值。但上上个例子中，`obj = new Object();`修改了`obj`的值，它存储的就不是一个指向原来对象的指针了，它被赋值成一个新的对象了，这时它就与传入的`person`完全没有关系了，是两个独立的对象。即使更改它的属性，也不会影响到`person`对象。

### 检测实例类型
之前使用`typeof`操作符和其他方法，检测类型主要是在检测基本数据类型。现在我们要检测一个实例对象是否属于某个类，这就要使用`instanceof`操作符了。它有两个特点：
1. 对任意基本数据类型的变量使用它，都会返回`false`，因为它们都不是对象。
2. 对任意引用类型如`Array`、`RegExp`、`Object`和`Function`使用`a instanceof Object`，都会返回`true`。它们都是`Object`的实例。

## 执行上下文与作用域
### 作用域、没有块级作用域
书上这一节中的例子有点小tricky。我按照自己的思路理解一下：
首先我们定义作用域：
>作用域实际上是一套获取代码执行上下文中的对象的规则。比如`function`对象所拥有的`arguments`对象，就存在于该`function`的执行上下文中，可以在该`function`的作用域中找到；全局变量存在于全局对象的执行上下文中，可以在全局作用域中找到。**作用域总共只有两种，一种是全局作用域，一种是函数级作用域，即局部作用域。**

然后定义作用域链：
>全局作用域可能包含多个局部作用域，局部作用域中又可能包含多个局部作用域，我们把每个作用域看成一个带有各种属性的对象，所有的对象都是全局对象的属性，而某个局部作用域的对象又有自己的属性，这个属性可能是变量，也可能是另一个作用域的对象。这样就形成了一个作用域链，但是这样的定义还不完全也不准确。

最后我们要定义作用域的“前”和“后”：
>全局作用域作为最开始存在的作用域，是作用域链延伸的起点，因此我们将它定义为后端，也就是说全局作用域是作用域链的末尾；  
  当前执行代码所在的作用域，我们定义为前端，因为在如果碰到一个新的局部作用域，进入到该作用域时，作用域链又延伸了一级。因此当前执行代码所在的作用域永远是最前端的。

现在我们要说明作用域访问规则了：
>内部作用域，也就是靠前端的作用域，可以沿着作用域链访问它上级的、外部的作用域，也就是靠后端的作用域；但后端作用域不能访问靠前端的作用域。

至此，作用域链的定义就完全了。但是，作用域链是可以延长的，通过`catch`和`with`语句，尽管后者从性能角度上并不推荐使用。需要注意的是，作用域链上的东西都是对象，我们在作用域链上要搜索的，要么是对象本身，要么是对象的属性。比如搜索一个变量，那可能就是作用域链上某个对象的属性；如果是调用函数，那么就要找作用域链上的某个对象（递归调用）或者是某个对象的属性对象（普通调用）。而书上的例子容易引起疑惑：
{% codeblock lang:javascript %}
function buildUrl() {
    var qs = "?debug=true";

    with(location) {
        var url = href + qs;
    }

    return url;
}
{% endcodeblock %}
这个例子中为什么`return`能返回`with`语句中的`url`呢？解决这个疑惑首先要明确两点：
1. 作用域类型只有两种，全局作用域和局部（函数）作用域，但它们的本质还是对象。
2. JavaScript中“没有块级作用域”是指，块级语句并不会产生一个作用域对象，而全局和函数都是对象。

因此这里使用`with`延长作用域链，是指下面的过程：
>1. `with`语句接受了`location`对象，于是就把它添加到了作用域链的最前端。
2. 尽管`with`语句本身没有作用域对象，但是当解释器碰到运算符，需要进行左搜索或者右搜索时，会从当前作用域链的最前端进行搜索。于是在碰到`href`时，搜索到了刚刚被添加到前端的`location`对象属性。
3. 而对于`url`，我们可以看到`location`中并没有这个属性。假如有这个属性，比如我们把`url`改成`hostname`，这是`location`对象中存在的属性，这时这里的`=`操作符就要闯祸了，解释器左搜索`hostname`时会从`location`对象中找到，并尝试给它赋值（前提是该属性可写）。也就是说`with`语句中，搜索作用域链是从最前端开始的。如果搜索不到，而它本身又没有作用域，那就进入当前函数作用域的上下文中。于是`url`实际上是在`buildUrl()`函数上下文中创建的一个局部变量。因此`return`能够返回它。

注意：`var`声明变量会被就近添加到上级作用域中，这也是为什么搜索不到`url`属性时，该变量被声明在了`buildUrl()`函数作用域中。

### 标识符提升：Hoisting
这里还要提及一个标识符提升的问题。

#### “变量提升”
实际上是根据`var`这个关键字命名的。直接举个栗子：
{% codeblock lang:javascript %}
var v='111';
(function(){
    alert(v);   //undefined
    var v='222';
})()
{% endcodeblock %}
实际上，在存在`var`的函数中，该语句是被提前到函数顶部的。即：
{% codeblock lang:javascript %}
var v='111';
(function() {
    var v;
    alert(v);   //undefined
    v='222';
})()
{% endcodeblock %}
定义了`v`但是未初始化，当然会返回`undefined`。

#### 函数提升
声明式函数，也会被提前。注意，只有声明式函数！函数表达式不可以！
{% codeblock lang:javascript %}
console.log(f1());
console.log(f2);
function f1() {
    return "f1";
}
var f2 = function() {
    return "f2";
};
{% endcodeblock %}
实际执行的代码等价于：
{% codeblock lang:javascript %}
function f1() {
    return "f1";
}
var f2;
f2 = function() {
    return "f2";
};
console.log(f1());
console.log(f2);
{% endcodeblock %}
并且，当函数和变量一同提升时，先提升函数，再提升变量。例子：
{% codeblock lang:javascript %}
console.log(foo);   
function foo(){
    console.log("function!");
}
var foo = "variable!";
{% endcodeblock %}
实际执行的代码等价于：
{% codeblock lang:javascript %}
function foo() {
    console.log("function!");
}
var foo;
console.log(foo);
foo = "variable!"
{% endcodeblock %}
可以看到，实际上变量和函数都被提升了，但是由于`foo`已经被初始化为函数名，该对象已经存在了，则后面的`var`就不会重置`foo`这个变量为`undefined`，而只是保留它原来的值：一个函数。之后的赋值才更改了它的值为一个字符串`variable`。

## 垃圾收集
### 标记清除
这是最常用的垃圾收集方式。核心思想就一句：
>**定期**清理带有特定标记的变量。

于是就两个问题：
1. 如何标记？
2. 如何清除？

标记策略各有不同。被标记的都是要删除的，那么刚声明的不能被标记，被别的变量引用的不能标记；除去上面两种之外，剩下的都标记上，准备清除。
清除就是销毁标记的变量，回收内存空间。

实际上这是一种垃圾回收算法，还有引用计数、标记压缩、复制算法。

### 引用计数
这一块的内容，思想和Linux内核的缓冲区回收机制类似。缓冲区的`buffer_head`里存在一个`b_count`来记录占用缓冲区块的进程个数，如果没有进程使用，则可能会被回收。但是一个严重的问题是**循环引用**。A引用B而B引用A，它们的引用计数永远不会为0。这时只能手动断开两个对象的联系。

### 性能
最早的IE的垃圾回收器会在被如下情况触发工作：
1. 存在256个变量
2. 4096个对象字面量
3. 64KB字符串

该机制会导致一些一直满足这些条件的大型脚本频繁触发垃圾回收机制。后来这种机制被改进，每次运行垃圾回收器后，回收的内存如果比较少，比如低于已分配内存的15%，则提高触发阈值；反之如果多于85%，则重置阈值到默认值。

如果某个变量不再使用，可以手动赋值为`null`，这样它将在下次垃圾回收器运行时被回收。
