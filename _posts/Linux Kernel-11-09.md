---
title:  "Linux内核 11-09"
date:   2015-11-09 17:00:00
cover: "2.jpg"
tags:
    - Linux
    - OS
category: "Linux"
---

## 缓冲区(续)
find_buffer通过设备号和块号在哈希表中寻找缓冲块。

缓冲区通过哈希表来管理，实际上是用哈希表来组织buffer_head。

这样做是为了追求更高的速度。

进程分页：4k
缓冲区块：1k
硬盘块设备：1k，两个扇区

块的概念是相对于操作系统而言的，对于硬盘它只有扇区柱面磁道。

重要的两点：4k打散，对齐排列

为了逻辑上形成一条从进程分页通过buffer_head到缓冲区再通过reqeust到文件系统的通路，bh应该与request标齐，设备号应该一致。

那么为何不可以直接读盘，而加了一道请求项这一工序？
>直接下读盘命令，下命令之后程序就不能接着向下执行了，要等，这一等就慢了，因为跟内存比硬盘速度太慢。
会不会等司机？不会，这是可以避免的。但是现代操作系统的设计思路是应对**实时多任务**操作，无请求项直接读，cpu挂起，其他进程抢占，怕就怕这个进程也来读盘，于是又是等待。实际上即使执行大量代码的时间也不及读盘等待的时间。这段时间就可能产生了许多变化，而缺乏管理机制肯定会出错，这就需要一个管理机制来防止出错。就是request。

在ll_rw_block中make_requst
接下来是bh request 块设备扇区的各种挂接过程
发出读盘命令就要等待，在sleep_on中调用调度函数。
在调用调度函数之前，将当前进程状态设置为不可中断，挂起。
接着开始调度，此时一共就两个进程，一个处于可中断等待，一个处于不可中断等待。

回到调度。
开始应该搜索就绪态的，**并且**时间片最多的进程。
虽然此时进程0还不是就绪，仍然可以ljmp过去。
ljmp相当于改变了当前进程的tss，跳转时，cou处于怠速因为没有running的进程也没有就绪的。是内核到内核的跳转。
